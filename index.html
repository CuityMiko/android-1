<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>一个大前端的 Android 开发日记 – ebook</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
div.sourceLine, a.sourceLine { display: inline-block; min-height: 1.25em; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; }
@media print {
code.sourceCode { white-space: pre-wrap; }
div.sourceLine, a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource div.sourceLine, .numberSource a.sourceLine
  { position: relative; }
pre.numberSource div.sourceLine::before, .numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em; }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; color: #aaaaaa;  padding-left: 4px; }
@media screen {
a.sourceLine::before { text-decoration: underline; color: initial; }
}
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.bn { color: #40a070; } /* BaseN */
code span.fl { color: #40a070; } /* Float */
code span.ch { color: #4070a0; } /* Char */
code span.st { color: #4070a0; } /* String */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.ot { color: #007020; } /* Other */
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.fu { color: #06287e; } /* Function */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code span.cn { color: #880000; } /* Constant */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.ss { color: #bb6688; } /* SpecialString */
code span.im { } /* Import */
code span.va { color: #19177c; } /* Variable */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.op { color: #666666; } /* Operator */
code span.bu { } /* BuiltIn */
code span.ex { } /* Extension */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.at { color: #7d9029; } /* Attribute */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <meta name="viewport" content="width=device-width">
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<p>
<h1>一个大前端的 Android 开发日记</h1>
<p>Phodal Huang</p>
</p>
<div style="width:800px">
<nav id="TOC">
<ul>
<li><a href="#大前端-android-开发日记一了解基本业务与技术栈">大前端 Android 开发日记一：了解基本业务与技术栈</a><ul>
<li><a href="#picasso"><strong>Picasso</strong></a></li>
<li><a href="#retrofit2"><strong>Retrofit2</strong></a></li>
<li><a href="#otto"><strong>otto</strong></a></li>
<li><a href="#rxjava2"><strong>RxJava2</strong></a></li>
<li><a href="#butterknife">ButterKnife</a></li>
<li><a href="#dagger">Dagger</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记二编写-mvp-依赖流入的-activity">大前端 Android 开发日记二：编写 MVP + 依赖流入的 Activity</a><ul>
<li><a href="#创建一个空白页">1.创建一个空白页</a></li>
<li><a href="#首页打开列表页">2.首页打开列表页</a></li>
<li><a href="#将参数传递到详情页">3.将参数传递到详情页</a></li>
<li><a href="#在详情页去获取数据">4.在详情页去获取数据</a></li>
<li><a href="#展示数据">5.展示数据</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记三使用-viewholder-与-xml-编写-ui">大前端 Android 开发日记三：使用 ViewHolder 与 XML 编写 UI</a><ul>
<li><a href="#viewholder-的事件">ViewHolder 的事件</a></li>
<li><a href="#获取-android-device-uuid">获取 Android Device UUID</a></li>
<li><a href="#实现-android-后退按钮">实现 Android 后退按钮</a></li>
<li><a href="#矢量图形vector-path">矢量图形：Vector Path</a></li>
<li><a href="#scrollview">ScrollView</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记四toolbar-问题及测试">大前端 Android 开发日记四：Toolbar 问题及测试</a><ul>
<li><a href="#模块化-apk-的-toolbar-后退按钮">模块化 APK 的 Toolbar 后退按钮</a></li>
<li><a href="#android-处理-toolbar-后退">Android 处理 Toolbar 后退</a></li>
<li><a href="#测试">测试</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记五代码重构">大前端 Android 开发日记五：代码重构</a><ul>
<li><a href="#android-manifest.xml">Android Manifest.xml</a></li>
<li><a href="#重构-deviceuuid-存储">重构 DeviceUUID 存储</a></li>
<li><a href="#android-后退按钮图片">Android 后退按钮图片</a></li>
<li><a href="#dagger-的-component-注入多个">Dagger 的 Component 注入多个</a></li>
<li><a href="#android-intent-传递-list">Android intent 传递 LIST</a></li>
<li><a href="#android-列表箭头图片">Android 列表箭头图片</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记六使用-mpandroidchat-开发图表应用">大前端 Android 开发日记六：使用 MPAndroidChat 开发图表应用</a><ul>
<li><a href="#使用-java-编写-layout">使用 Java 编写 Layout</a></li>
<li><a href="#mpandroidchat-y-轴">MPAndroidChat Y 轴</a></li>
<li><a href="#mpandroidchat-x-轴设置">MPAndroidChat X 轴设置</a></li>
<li><a href="#自定义-label-显示">自定义 LABEL 显示</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记七mpandroidchat-填坑笔记">大前端 Android 开发日记七：MPAndroidChat 填坑笔记</a><ul>
<li><a href="#mpandroidchat-自定义-marker">MPAndroidChat 自定义 Marker</a></li>
<li><a href="#android-vector-圆圈">Android Vector 圆圈</a></li>
<li><a href="#mpandroidchat-生成位置">MPAndroidChat 生成位置</a></li>
<li><a href="#添加子布局">添加子布局</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记八android-短信微信微博分享">大前端 Android 开发日记八：Android 短信、微信、微博分享</a><ul>
<li><a href="#toolbar-上的分享按钮">Toolbar 上的分享按钮</a></li>
<li><a href="#短信分享示例">短信分享示例</a></li>
<li><a href="#使用-dialog-绘制底部分享">使用 Dialog 绘制底部分享</a></li>
<li><a href="#使用-bottomsheetdialog-绘制分享菜单">使用 BottomSheetDialog 绘制分享菜单</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记九微博分享">大前端 Android 开发日记九：微博分享</a><ul>
<li><a href="#短信分享返回">短信分享返回</a></li>
<li><a href="#微博分享接入">微博分享接入</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记-10微信分享">大前端 Android 开发日记 10：微信分享</a><ul>
<li><a href="#微信分享-sdk-接入">微信分享 SDK 接入</a></li>
<li><a href="#注册-wxapi">注册 WXApi</a></li>
<li><a href="#分享逻辑">分享逻辑</a></li>
<li><a href="#使用-wxentryactivity-做出响应">使用 WXEntryActivity 做出响应</a></li>
<li><a href="#使用-eventbus-传递事件">使用 EventBus 传递事件</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记-11日历创建">大前端 Android 开发日记 11：日历创建</a><ul>
<li><a href="#日历权限">日历权限</a></li>
<li><a href="#权限判断">权限判断</a></li>
<li><a href="#请求权限">请求权限</a></li>
<li><a href="#请求权限回调">请求权限回调</a></li>
<li><a href="#添加前检测权限">添加前检测权限</a></li>
<li><a href="#创建日历事件">创建日历事件</a></li>
<li><a href="#添加提醒">添加提醒</a></li>
<li><a href="#获取所有的日历">获取所有的日历</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记-12删除日历状态变化">大前端 Android 开发日记 12：删除日历、状态变化</a><ul>
<li><a href="#合并日历的状态">合并日历的状态</a></li>
<li><a href="#删除日历">删除日历</a></li>
<li><a href="#实时更新日历状态">实时更新日历状态</a></li>
</ul></li>
<li><a href="#大前端-android-开发日记-13动态更新日历状态">大前端 Android 开发日记 13：动态更新日历状态</a><ul>
<li><a href="#动态更新日历状态">动态更新日历状态</a><ul>
<li><a href="#使用-eventbus-创建通知事件">1.使用 EventBus 创建通知事件</a></li>
<li><a href="#接收事件并传递给-adapter">2.接收事件，并传递给 Adapter</a></li>
<li><a href="#更新-item">3. 更新 Item</a></li>
<li><a href="#更新状态">4. 更新状态</a></li>
</ul></li>
</ul></li>
<li><a href="#大前端-android-开发日记-14纯-html-的-webview-loading-效果">大前端 Android 开发日记 14：纯 HTML 的 WebView Loading 效果</a><ul>
<li><a href="#通常的-webview-loading-效果">通常的 WebView Loading 效果</a></li>
<li><a href="#本地-webview-loading-效果">本地 WebView Loading 效果</a></li>
</ul></li>
</ul>
</nav>
<h1 id="大前端-android-开发日记一了解基本业务与技术栈">大前端 Android 开发日记一：了解基本业务与技术栈</h1>
<p>初来的第一天，由项目的开发人员及业务人员，介绍了项目的业务知识。由于产权限制，这里就不多说业务相关的知识了。</p>
<p>简单的记录一下，项目所用到的 Android 技术栈。</p>
<h2 id="picasso"><strong>Picasso</strong></h2>
<p>Picasso 是Square公司开源的一个Android图形缓存库，可以实现图片下载和缓存功能。官网地址: http://square.github.io/picasso/</p>
<p>其使用方式也很简单：</p>
<pre><code>Picasso.with(context).load(&quot;http://i.imgur.com/DvpvklR.png&quot;).into(imageView);</code></pre>
<h2 id="retrofit2"><strong>Retrofit2</strong></h2>
<p>Retrofit2 是一个用于 Android 和 Java 平台的类型安全的网络框架。</p>
<p>可以支持这种路径的参数获取：</p>
<pre><code>public interface GitHubService {
  @GET(&quot;users/{user}/repos&quot;)
  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
}</code></pre>
<p>以及：</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com/&quot;)
    .build();

GitHubService service = retrofit.create(GitHubService.class);</code></pre>
<p>我们唯一要做的比较麻烦的可能是构建模型。</p>
<h2 id="otto"><strong>otto</strong></h2>
<p>Otto 是 square 公司出的一个事件库（pub/sub模式），用来简化应用程序组件之间的通讯。如下是一个简单的例子：</p>
<pre><code>@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View rootView = inflater.inflate(R.layout.fragment_main, container, false);
    View button = rootView.findViewById(R.id.fragmentbutton);
    button.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            bus.post(&quot;Hello from the Fragment&quot;);
        }
    });
    bus.register(this);
    return rootView;
}

@Subscribe
public void getMessage(String message) {
    Toast.makeText(getActivity(), message, Toast.LENGTH_SHORT).show();
}</code></pre>
<h2 id="rxjava2"><strong>RxJava2</strong></h2>
<p>RxJava 是一个 Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences。</p>
<blockquote>
<p>一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。</p>
</blockquote>
<p>总之就是这样的：</p>
<pre><code>Observable.zip(getCricketFansObservable(), getFootballFansObservable(),
        new BiFunction&lt;List&lt;User&gt;, List&lt;User&gt;, List&lt;User&gt;&gt;() {
            @Override
            public List&lt;User&gt; apply(List&lt;User&gt; cricketFans, List&lt;User&gt; footballFans) throws Exception {
                return Utils.filterUserWhoLovesBoth(cricketFans, footballFans);
            }
        })
        // Run on a background thread
        .subscribeOn(Schedulers.io())
        // Be notified on the main thread
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(getObserver());</code></pre>
<h2 id="butterknife">ButterKnife</h2>
<p>ButterKnife 是一个使用注解方式来为 Android 中的 View 视图绑定字段和方法，能通过自动解析注解来搜索资源文件并赋值给 Activity 中的字段。</p>
<p>简单的来说就是简化我们的绑定：</p>
<pre><code>class ExampleActivity extends Activity {
  @BindView(R.id.title) TextView title;
  @BindView(R.id.subtitle) TextView subtitle;
  @BindView(R.id.footer) TextView footer;

  @Override public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.simple_activity);
    ButterKnife.bind(this);
    // TODO Use fields...
  }
}</code></pre>
<h2 id="dagger">Dagger</h2>
<p>Dagger 是目前最流行的专为 Android 设计的依赖注入函数库。</p>
<p>就是有些复杂：</p>
<pre><code>@Module(injects = {App.class})
public class AppModule {

    private App app;

    public AppModule(App app) {
        this.app = app;
    }

    @Provides @Singleton public Context provideApplicationContext() {
        return app;
    }
}</code></pre>
<h1 id="大前端-android-开发日记二编写-mvp-依赖流入的-activity">大前端 Android 开发日记二：编写 MVP + 依赖流入的 Activity</h1>
<p>在这一天里，我接到了一张新的业务卡，从技术上来说就是：从列表页打开一个详情页。</p>
<p>而详情页的入口有两部分，一个是在首页，一个是在列表页。而首页是一个独立的 APK，因此在启动方式就是采用 Actvitiy 来启动。</p>
<p>因此，我做了一个简单的 Task，来做这个卡：</p>
<ol type="1">
<li>创建一个空白的详情页</li>
<li>从首页打开详情页</li>
<li>将参数传递到详情页</li>
<li>在详情页去获取数据</li>
<li>展示数据</li>
<li>优化 UI（留给第二天）</li>
</ol>
<h2 id="创建一个空白页">1.创建一个空白页</h2>
<p>这一步就比较简单了，网上找个 Hello, world 放置一下就可以了：</p>
<p>首先在 <code>AndroidManifest.xml</code> 中添加我们的入口 actvity：</p>
<pre><code>       &lt;activity
          android:name=&quot;.DetailActivity&quot;
          android:label=&quot;@string/title_activity_main&quot; &gt;

          &lt;intent-filter&gt;
             &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
             &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
          &lt;/intent-filter&gt;

       &lt;/activity&gt;</code></pre>
<p>然后创建好这个 activity：</p>
<pre><code>package com.example.helloworld;

import android.os.Bundle;
import android.app.Activity;
import android.view.Menu;
import android.view.MenuItem;
import android.support.v4.app.NavUtils;

public class MainActivity extends Activity {

   @Override
   public void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);
   }

   @Override
   public boolean onCreateOptionsMenu(Menu menu) {
      getMenuInflater().inflate(R.menu.activity_main, menu);
      return true;
   }
}</code></pre>
<p>以及对应的 Layout：</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
   xmlns:tools=&quot;http://schemas.android.com/tools&quot;
   android:layout_width=&quot;match_parent&quot;
   android:layout_height=&quot;match_parent&quot; &gt;

   &lt;TextView
      android:layout_width=&quot;wrap_content&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:layout_centerHorizontal=&quot;true&quot;
      android:layout_centerVertical=&quot;true&quot;
      android:padding=&quot;@dimen/padding_medium&quot;
      android:text=&quot;@string/hello_world&quot;
      tools:context=&quot;.MainActivity&quot; /&gt;

&lt;/RelativeLayout&gt;</code></pre>
<h2 id="首页打开列表页">2.首页打开列表页</h2>
<p>这部分的代码比较简单，如下所示：</p>
<pre><code>Intent intent = new Intent();
intent.setComponent(new ComponentName(&quot;com.example&quot;, &quot;com.example.MyExampleActivity&quot;));
startActivity(intent);</code></pre>
<p>不过，我一开始写的代码是错的。</p>
<h2 id="将参数传递到详情页">3.将参数传递到详情页</h2>
<p>这一步也不难，就是先 putExtras 再 getExtras：</p>
<pre><code>Intent intent = new Intent();
intent.setComponent(new ComponentName(&quot;com.example&quot;, &quot;com.example.MyExampleActivity&quot;));
intent.putExtra(&quot;id&quot;, id);            
startActivity(intent);</code></pre>
<p>再在我们的 Activity 中获取参数：</p>
<pre><code>    String newString;
    Bundle extras = getIntent().getExtras();
    if (extras == null) {
        newString = &quot;123&quot;;
    } else {
        newString = extras.getString(&quot;id&quot;);
    }</code></pre>
<h2 id="在详情页去获取数据">4.在详情页去获取数据</h2>
<p>我本来以为这一部分很简单，但是没想到的是我们的 Android 项目是遵循 Google 推荐的 MVP 架构。可以在 Google Samples 看到一个相关的示例：<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp">todo-mvp</a></p>
<p>按照这个架构，我们需要有：</p>
<ul>
<li>Model，在其中定义我们的数据结构，对应于后台的 API</li>
<li>View，定义显示相关的逻辑，具体逻辑会由 Activity 实现</li>
<li>Presenter，处理事件，检索 Model 获取数据等等</li>
<li>Repository，作为数据源，来处理远程或者本地的数据</li>
</ul>
<p>让我们看看这个 Todo 的 Model：</p>
<pre><code>@Entity(tableName = &quot;tasks&quot;)
public final class Task {
    @PrimaryKey
    @NonNull
    @ColumnInfo(name = &quot;entryid&quot;)
    private final String mId;

    @Nullable
    @ColumnInfo(name = &quot;title&quot;)
    private final String mTitle;

    @Nullable
    @ColumnInfo(name = &quot;description&quot;)
    private final String mDescription;

    @ColumnInfo(name = &quot;completed&quot;)
    private final boolean mCompleted;

    @Ignore
    public Task(@Nullable String title, @Nullable String description) {
        this(title, description, UUID.randomUUID().toString(), false);
    }
    ...
}</code></pre>
<p>如下是一个 View 的示例：</p>
<pre><code>package com.example.android.architecture.blueprints.todoapp;

public interface BaseView&lt;T&gt; {

    void setPresenter(T presenter);

}</code></pre>
<p>下面是一个 Presenter 的示例：</p>
<pre><code>package com.example.android.architecture.blueprints.todoapp;

public interface BasePresenter {

    void start();

}</code></pre>
<p>对应的还有处理请求的 Repository：</p>
<pre><code>public class TasksRepository implements TasksDataSource {

    ...
        @Override
    public void getTasks(@NonNull final LoadTasksCallback callback) {

    })
}</code></pre>
<p>而为了使用 Dagger 来做依赖注入，还需要额外的：</p>
<ul>
<li>Module</li>
<li>Component</li>
</ul>
<p>如下是一个 Dagger 的简单示例（来源：<a href="http://codethink.me/2015/08/06/dependency-injection-with-dagger-2/">使用Dagger 2进行依赖注入</a>）：</p>
<p>Module 用于提供依赖：</p>
<pre><code>@Module
public class ActivityModule {
    @Provides UserModel provideUserModel() {
        return new UserModel();
    }
}</code></pre>
<p>component 负责连接提供依赖和消费依赖对象：</p>
<pre><code>@Component(modules = ActivityModule.class)
public interface ActivityComponent {
    void inject(MainActivity activity);
}</code></pre>
<p>然后就可以愉快地使用了：</p>
<pre><code>    @Inject
    UserModel userModel;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        mActivityComponent = DaggerActivityComponent.builder().activityModule(new ActivityModule()).build();
        mActivityComponent.inject(this);
    })</code></pre>
<h2 id="展示数据">5.展示数据</h2>
<p>当我们 Activity 将会继承自上面的 View，以及实现对应的逻辑：</p>
<pre><code>@Override
public void showDetail(TaskDetailModel task) {
    ViewHolder viewHolder = new ViewHolder(content);
    ViewHolder.populate(task);
}</code></pre>
<p>我们将对应的展示交由 ViewHoler 来实现：</p>
<pre><code>public class ViewHolder extends RecyclerView.ViewHolder {

    private final View view;


    @BindView(R.id.webview)
    WebView webview;

    public InformationDetailViewHolder(View view) {
        super(view);
        this.view = view;
        ButterKnife.bind(this, this.view);
    }

    void populate(InformationDetailModel InformationDetail) {
        webview.loadData(InformationDetail.getContent(), &quot;text/html; charset=utf-8&quot;, &quot;UTF-8&quot;);
    }
}</code></pre>
<p>就是这么复杂。</p>
<h1 id="大前端-android-开发日记三使用-viewholder-与-xml-编写-ui">大前端 Android 开发日记三：使用 ViewHolder 与 XML 编写 UI</h1>
<p>在之前的两天里，我花了大量的时间在熟悉系统的架构上。因此，在这一天里，我主要花费的时间都是在编写 UI 上，以及对应的一些事件处理。</p>
<h2 id="viewholder-的事件">ViewHolder 的事件</h2>
<p>按官网的说明：</p>
<blockquote>
<p>一个 ViewHolder 描述一个项目视图和关于它在 RecyclerView 中的位置的元数据。</p>
</blockquote>
<p>对于我使用例子是，我是在我的列表中的条目中使用 ViewHolder，因此每个条目都是单一的 view。这是一个示例的 ViewHolder，我在它的构建类里添加了一个 onClick 事件：</p>
<pre class="sourceCode java" id="cb23"><code class="sourceCode java"><div class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">public</span> <span class="kw">class</span> RelatedViewHolder <span class="kw">extends</span> RecyclerView.<span class="fu">ViewHolder</span> {</div>
<div class="sourceLine" id="cb23-2" data-line-number="2">    <span class="kw">public</span> <span class="fu">RelatedNewsViewHolder</span>(<span class="bu">View</span> view) {</div>
<div class="sourceLine" id="cb23-3" data-line-number="3">        <span class="kw">super</span>(view);</div>
<div class="sourceLine" id="cb23-4" data-line-number="4">        <span class="kw">this</span>.<span class="fu">view</span> = view;</div>
<div class="sourceLine" id="cb23-5" data-line-number="5">        ButterKnife.<span class="fu">bind</span>(<span class="kw">this</span>, view);</div>
<div class="sourceLine" id="cb23-6" data-line-number="6"></div>
<div class="sourceLine" id="cb23-7" data-line-number="7">        <span class="fu">onClick</span>(view);</div>
<div class="sourceLine" id="cb23-8" data-line-number="8">    }</div>
<div class="sourceLine" id="cb23-9" data-line-number="9">}</div></code></pre>
<p>而在这个 Click 事件里，启动了一个新的 Activity：</p>
<pre><code>public void onClick(View itemView) {
    itemView.setOnClickListener(view -&gt; {
        Intent intent = new Intent();
        Context context = itemView.getContext();

        intent.setComponent(new ComponentName(context, DetailActivity.class));
        context.startActivity(intent);
    });
}</code></pre>
<p>在这里面里，我们会启动一个新的 Activity。</p>
<h2 id="获取-android-device-uuid">获取 Android Device UUID</h2>
<p>在实现的过程中，还需要一个获取设备的 UUID。DeviceID 有一个问题时，用户可能不会同意获取，于是还需要一个新的 UUID。为了简化这个逻辑，直接使用 Google 推荐的 UUID，而不是再去用 DeviceID。</p>
<pre><code>public class DeviceUtil {
    private static String uniqueID = null;
    private static final String PREF_UNIQUE_ID = &quot;PREF_UNIQUE_ID&quot;;

    public synchronized static String getDeviceUUID(Context context) {
        if (uniqueID == null) {
            SharedPreferences sharedPrefs = context.getSharedPreferences(
                    PREF_UNIQUE_ID, Context.MODE_PRIVATE);
            uniqueID = sharedPrefs.getString(PREF_UNIQUE_ID, null);
            if (uniqueID == null) {
                uniqueID = UUID.randomUUID().toString();
                SharedPreferences.Editor editor = sharedPrefs.edit();
                editor.putString(PREF_UNIQUE_ID, uniqueID);
                editor.apply();
            }
        }
        return uniqueID;
    }
}</code></pre>
<p>在这个逻辑里，会判断机器上是否存储有之前的 UUID。如果没有的话，就生成一个新的；反之，则从 SharedPreferences 中获取一份。</p>
<h2 id="实现-android-后退按钮">实现 Android 后退按钮</h2>
<p>由于打开的是新的页面，因此需要自己做一个 Toolbar，相应的配置代码如下所示：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;android.support.v7.widget.Toolbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:toolbar=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/toolbar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;?attr/actionBarSize&quot;
    android:background=&quot;?attr/colorPrimaryDark&quot;
    android:gravity=&quot;center&quot;
    app:theme=&quot;@style/ToolbarColoredBackArrow&quot;
    toolbar:titleTextColor=&quot;@color/cmb_white&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/toolbar_title&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_gravity=&quot;center&quot;
        android:text=&quot;xxx&quot; /&gt;

&lt;/android.support.v7.widget.Toolbar&gt;</code></pre>
<p>接着，定制一个新的返回按钮标题：</p>
<pre><code>&lt;style name=&quot;ToolbarColoredBackArrow&quot; parent=&quot;AppTheme&quot;&gt;
    &lt;item name=&quot;android:textColorSecondary&quot;&gt;#FFFFFF&lt;/item&gt;
&lt;/style&gt;</code></pre>
<p>然后，导入这个 xml：</p>
<pre><code>&lt;include layout=&quot;@layout/toolbar&quot; /&gt;</code></pre>
<p>同时在我们的 Activity 中添加对应的事件处理：</p>
<pre><code>@Override
public boolean onOptionsItemSelected(MenuItem item) {
    if (item.getItemId() == android.R.id.home) {
        onBackPressed();
        return true;
    }
    return super.onOptionsItemSelected(item);
}</code></pre>
<h2 id="矢量图形vector-path">矢量图形：Vector Path</h2>
<p>还遇到一个很有遇到的问题是，可以在 Android 中使用类似于 SVG 的 Vector：</p>
<pre><code>&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
     android:height=&quot;64dp&quot;
     android:width=&quot;64dp&quot;
     android:viewportHeight=&quot;600&quot;
     android:viewportWidth=&quot;600&quot; &gt;
     &lt;group
         android:name=&quot;rotationGroup&quot;
         android:pivotX=&quot;300.0&quot;
         android:pivotY=&quot;300.0&quot;
         android:rotation=&quot;45.0&quot; &gt;
         &lt;path
             android:name=&quot;v&quot;
             android:fillColor=&quot;#000000&quot;
             android:pathData=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot; /&gt;
     &lt;/group&gt;
 &lt;/vector&gt;</code></pre>
<p>它也是类似的使用 Path，来描述 UI。</p>
<h2 id="scrollview">ScrollView</h2>
<p>最后，花费了一些时间在编写一个 ScrollView 上，结合了之前上面的 Toolbar 等内容：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@color/cmb_white&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;include layout=&quot;@layout/toolbar&quot; /&gt;

    &lt;ScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:scrollbars=&quot;none&quot;&gt;

        &lt;LinearLayout
            android:id=&quot;@+id/detail&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:orientation=&quot;vertical&quot;&gt;

        &lt;/LinearLayout&gt;
    &lt;/ScrollView&gt;
&lt;/LinearLayout&gt;</code></pre>
<h1 id="大前端-android-开发日记四toolbar-问题及测试">大前端 Android 开发日记四：Toolbar 问题及测试</h1>
<p>在之前的两天里，已经实现了大部分的功能。但是，仍然遇到了一些 Toolbar 的问题，除了努力地解决这个问题之外，还写了几个简单的测试。</p>
<h2 id="模块化-apk-的-toolbar-后退按钮">模块化 APK 的 Toolbar 后退按钮</h2>
<p>由于应用程序采用的是类似于 RePlugin 的插件化机制。因为在使用样式来将 Toolbar 改为白色的时候，在另外一个 APK 里没有对应的资源。于是，便想着将 Toolbar 改成了个组件：</p>
<pre><code>&lt;RelativeLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;56dp&quot;
    android:background=&quot;@color/black&quot;
    android:gravity=&quot;center_vertical&quot;&gt;

    &lt;include layout=&quot;@layout/back_button&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_centerHorizontal=&quot;true&quot;
        android:padding=&quot;@dimen/length_16&quot;
        android:text=&quot;@string/something&quot;/&gt;

&lt;/RelativeLayout&gt;</code></pre>
<p>对应的后退按钮：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/fast_back&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;ImageView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingEnd=&quot;@dimen/length_24&quot;
        android:paddingStart=&quot;@dimen/length_16&quot;
        android:paddingTop=&quot;@dimen/length_16&quot;
        android:paddingBottom=&quot;@dimen/length_16&quot;
        android:src=&quot;@drawable/back_icon&quot;/&gt;

&lt;/LinearLayout&gt;</code></pre>
<p>这样在另外一个 APK 中，只需要有相应的图片资源即可。在 Code Diff 的时候，被告知这个可以用图片来实现——做的时候，忘记了这个。只能明天再去改吧。</p>
<h2 id="android-处理-toolbar-后退">Android 处理 Toolbar 后退</h2>
<p>对应的处理后退的逻辑，也由：</p>
<pre><code>@Override
public boolean onOptionsItemSelected(MenuItem item) {
    if (item.getItemId() == android.R.id.home) {
        onBackPressed();
        return true;
    }
    return super.onOptionsItemSelected(item);
}</code></pre>
<p>变成了简单的后退了。</p>
<pre><code>@OnClick(R.id.fast_back)
void clickBackText() {
    onBackPressed();
}</code></pre>
<h2 id="测试">测试</h2>
<p>完成了对 Toolbar 的控制之后，我便写了一个测试：</p>
<pre><code>    @Mock
    private DetailView detailView;
    @Mock
    private DetailRepository detailRepository;

    private DetailPresenter detailPresenter;

    @Test
    public void shouldShowDetail() throws Exception {
        DetailModel detail = mock(DetailModel.class);
        when(detail.getText()).thenReturn(anyListOf(Related.class));

        detailPresenter.onLoadDetailSuccess(detail);
        verify(detailView).showDetail(any(DetailModel.class));
    }</code></pre>
<p>在这个测试里，简单的测试了一个回调成功时，会调用显示详情的逻辑。</p>
<h1 id="大前端-android-开发日记五代码重构">大前端 Android 开发日记五：代码重构</h1>
<p>本来在上一天里，我已经完成了业务的功能。在 Code Review 的时候，代码中有一些不符合 Android 的实践，又或者是有更好的方式。</p>
<p>这些不好的 Code Smell，比如说：</p>
<ol type="1">
<li>在 AndroidManifest.xml 中有没有使用的 Intent Filted</li>
<li>测试的时候，漏掉了 null 的情况</li>
<li>其它代码中使用了单词缩写，应该改为全称</li>
<li>代码中已经有一个 SharedPreferences 工具类</li>
<li>Toolbar （回退按钮）的图标可以在 Java 代码里设置</li>
</ol>
<p>花了一个小时重构完之后，我便开始写新的业务卡。</p>
<h2 id="android-manifest.xml">Android Manifest.xml</h2>
<p>由于事先不是很了解 Android 的一些 xml 配置，便直接复制了原先的 MainActivity。当然，这些代码是多余的：</p>
<pre><code>&lt;intent-filter&gt;
    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;</code></pre>
<p>按 Android 官方的文档：</p>
<blockquote>
<p>应用的核心组件（例如其 Activity、服务和广播接收器）由 intent 激活。Intent 是一系列用于描述所需操作的信息（Intent 对象），其中包括要执行操作的数据、应执行操作的组件类别以及其他相关说明。Android 系统会查找合适的组件来响应 intent，根据需要启动组件的新实例，并将其传递到 Intent 对象。</p>
</blockquote>
<blockquote>
<p>组件将通过 intent 过滤器公布它们可响应的 intent 类型。由于Android 系统在启动某组件之前必须了解该组件可以处理的 intent，因此 intent 过滤器在清单中被指定为 <intent-filter> 元素。一个组件可有任意数量的过滤器，其中每个过滤器描述一种不同的功能。</p>
</blockquote>
<p>相关的解释如下</p>
<ul>
<li>android.intent.action.MAIN 决定应用程序最先启动的Activity</li>
<li>android.intent.category.LAUNCHER 决定应用程序是否显示在程序列表里</li>
</ul>
<p>因此，便删了这两行代码。</p>
<h2 id="重构-deviceuuid-存储">重构 DeviceUUID 存储</h2>
<p>SharedPreferences API 是一种类似于 LocalStorage 的读写键值接口。最大的区别是，SharedPreferences 是以文件名来保存的。</p>
<p>这就意味着我们需要从某个地方来放置一个文件名相关的变量，因此更好的方式是有一个 SharedPreferences 的公共类。它负责做这些相关的事件：</p>
<pre><code>@SuppressLint(&quot;ApplySharedPref&quot;)
public void setDeviceUUIDPref(String value) {
    pref.edit().putString(PREF_UNIQUE_ID, value).commit();
}

@SuppressLint(&quot;ApplySharedPref&quot;)
public String getDeviceUUIDPref() {
    return pref.getString(PREF_UNIQUE_ID, null);
}</code></pre>
<p>然后，我们从来读取数据：</p>
<pre><code>public class DeviceUtil {
    private static String uniqueID = null;

    public synchronized static String getDeviceUUID(Context context) {
        PreferencesHelper sharedPrefs = new PreferencesHelper(context);
        uniqueID = sharedPrefs.getDeviceUUIDPref();
        if (uniqueID == null) {
            uniqueID = UUID.randomUUID().toString();
            sharedPrefs.setDeviceUUIDPref(uniqueID);
        }
        return uniqueID;
    }
}</code></pre>
<p>这样就可以保证，我们读取的是同一个文件。</p>
<h2 id="android-后退按钮图片">Android 后退按钮图片</h2>
<p>再回到那个 Android 后退按钮的图片问题，可以直接使用：</p>
<pre><code>actionBar.setHomeAsUpIndicator(R.drawable.back_icon);</code></pre>
<p>这样就可以设置上图片了：</p>
<pre><code>setSupportActionBar(toolbar);
ActionBar actionBar = getSupportActionBar();
if (actionBar != null) {
    actionBar.setDisplayHomeAsUpEnabled(true);
    actionBar.setDisplayShowTitleEnabled(false);
    actionBar.setDisplayShowHomeEnabled(true);
    actionBar.setHomeAsUpIndicator(R.drawable.back_icon);
}</code></pre>
<h2 id="dagger-的-component-注入多个">Dagger 的 Component 注入多个</h2>
<p>因为新建了一个 Activity，就需要注入新的 Component：</p>
<pre><code>@PerActivity
@Component(dependencies = ApplicationComponent.class, modules = HomeModule.class)
public interface HomeComponent {

    void inject(HomeFragment homeFragment);

    void inject(DetailActivity detailActivity);
}</code></pre>
<h2 id="android-intent-传递-list">Android intent 传递 LIST</h2>
<p>在实现新业务的过程中，还遇到一个使用 intent 传递 LIST 的情形，一种比较简单的方式是使用 Serializable 来实现：</p>
<pre><code>public class Model implements Serializable {

}</code></pre>
<p>然后 put 进去：</p>
<pre><code>intent.putExtra(&quot;model&quot;, (Serializable) model);</code></pre>
<p>接着，再用的地方转换一下，读取出来：</p>
<pre><code>List&lt;Model&gt; model = null;
Bundle extras = getIntent().getExtras();
if (extras == null) {
    onBackPressed();
} else {
    model = (List&lt;Model&gt;) getIntent().getSerializableExtra(&quot;model&quot;);
}</code></pre>
<h2 id="android-列表箭头图片">Android 列表箭头图片</h2>
<p>在实现一个列表的时候，用到了一个箭头。这个箭头正好要水平居中，你懂的。就有了如下的 XML：</p>
<pre><code>&lt;android.support.v7.widget.AppCompatImageView
    android:id=&quot;@+id/chevron_right&quot;
    android:visibility=&quot;gone&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_alignParentEnd=&quot;true&quot;
    android:layout_centerVertical=&quot;true&quot;
    app:srcCompat=&quot;@drawable/ic_chevron_right&quot; /&gt;</code></pre>
<h1 id="大前端-android-开发日记六使用-mpandroidchat-开发图表应用">大前端 Android 开发日记六：使用 MPAndroidChat 开发图表应用</h1>
<p>在完成了基本的业务功能之后，我开始去画相应的图表。这不是一件简单的事，尽管已经有了 MPAndroidChart 这样的图表工具。但是显然，它带来的问题，可能比解决的问题还多。</p>
<p>这一天做的事情比较少，主要是在做（学习，边做边学）图表相关的内容。</p>
<h2 id="使用-java-编写-layout">使用 Java 编写 Layout</h2>
<p>在这之前，我完全不知道，怎么用 Java 代码去写一个自定义的布局，即如下的示例：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@color/cmb_white&quot;
   
    &lt;com.phodal.app.LineChart
        android:id=&quot;@+id/line_chart&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;160dp&quot; /&gt;

&lt;/LinearLayout&gt;</code></pre>
<p>这里的 LineChart 就是一个自定义的布局，下面就是对应的类。</p>
<pre><code>public class LineChart extends RelativeLayout {

    public LineChart(Context context, AttributeSet attr) {
        super(context, attr);
        view = LayoutInflater.from(context).inflate(R.layout.chart_layout, this);
    }
}</code></pre>
<p>在这里，我们就可以进行相应的元素操作了。</p>
<h2 id="mpandroidchat-y-轴">MPAndroidChat Y 轴</h2>
<p>然后就是一些 MPAndroidChat 相应的设置。在 MPAndroidChat 中，传统的 Y 轴是叫 LeftAxis：</p>
<pre><code>YAxis leftAxis = chart.getAxisLeft();
leftAxis.removeAllLimitLines(); 
leftAxis.enableGridDashedLine(10f, 10f, 0f);
leftAxis.setDrawZeroLine(false);
leftAxis.setDrawLimitLinesBehindData(true);</code></pre>
<h2 id="mpandroidchat-x-轴设置">MPAndroidChat X 轴设置</h2>
<p>以及 X 轴相关的一些设备：</p>
<pre><code>XAxis xAxis = chart.getXAxis();
xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);
xAxis.setDrawGridLines(true);
xAxis.setGranularity(1f);
IAxisValueFormatter CustomAxisFormatter = new DateAxisFormatter();
xAxis.setValueFormatter(xAxisFormatter);
xAxis.enableGridDashedLine(10f, 10f, 0f);</code></pre>
<h2 id="自定义-label-显示">自定义 LABEL 显示</h2>
<p>对应的，还有相应的格式化数据的逻辑：</p>
<pre><code>public class CustomAxisFormatter implements IAxisValueFormatter {
    @Override
    public String getFormattedValue(float value, AxisBase axis) {
        Date date = new Date((long) value);
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;MM-dd&quot;, Locale.CHINA);
        return sdf.format(date);
    }
}</code></pre>
<h1 id="大前端-android-开发日记七mpandroidchat-填坑笔记">大前端 Android 开发日记七：MPAndroidChat 填坑笔记</h1>
<p>继续上一天的 MPAndroidChat 填坑记录。</p>
<h2 id="mpandroidchat-自定义-marker">MPAndroidChat 自定义 Marker</h2>
<p>首先，是自定义用来 Highlight 的 Marker。代码如下所示：</p>
<pre><code>@SuppressLint(&quot;ViewConstructor&quot;)
public class DescriptionChartMarkerView extends MarkerView {
    private TextView content;
    private int startIndex;

    public DescriptionChartMarkerView(Context context, int layoutResource) {
        super(context, layoutResource);
        content = (TextView) findViewById(R.id.view);
    }

    @SuppressLint(&quot;DefaultLocale&quot;)
    @Override
    public void refreshContent(Entry e, Highlight highlight) {
        super.refreshContent(e, highlight);
        content.setText(String.format(&quot;%d&quot;, startIndex + 1));
        startIndex++;
    }

    public void setStartIndex(int startIndex) {
        this.startIndex = startIndex;
    }
}</code></pre>
<h2 id="android-vector-圆圈">Android Vector 圆圈</h2>
<p>在实现的过程中，需要画一个圆圈，也就有了：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;oval&quot;&gt;

    &lt;solid
        android:color=&quot;@color/green&quot;/&gt;

    &lt;size
        android:width=&quot;@dimen/text_size_14&quot;
        android:height=&quot;@dimen/text_size_14&quot;/&gt;
&lt;/shape&gt;</code></pre>
<h2 id="mpandroidchat-生成位置">MPAndroidChat 生成位置</h2>
<p>一般来说，我们可以通过下面的代码来生成 Position 的位置，但是好似是不工作的：</p>
<pre><code>chart.getTransformer(chart.getLineData().mDataSets.get(0).getAxisDependency()).getPixelForValues(highlights[index].getX(), highlights[index].getY());</code></pre>
<h2 id="添加子布局">添加子布局</h2>
<p>在上一步获取位置之后，接下来就是将对应的点绘制在坐标上：</p>
<pre><code>View marker = LayoutInflater.from(getContext()).inflate(R.layout.marker, view, false);
RelativeLayout.LayoutParams params  = (RelativeLayout.LayoutParams) marker.getLayoutParams();

TextView textView = (TextView) marker.findViewById(R.id.text_view);
textView.setText(String.format(&quot;%d&quot;, i));

params.leftMargin = 20
params.topMargin = 20

marker.setLayoutParams(params);
view.addView(marker);</code></pre>
<h1 id="大前端-android-开发日记八android-短信微信微博分享">大前端 Android 开发日记八：Android 短信、微信、微博分享</h1>
<p>在纠结了几天的图表功能之后，我开始开发一个新的功能。即分享内容到短信、微信、微博等渠道，对应的我有一个简单的 Task：</p>
<ul>
<li>在 Toolbar 写分享的按钮</li>
<li>绘制一个 Android 的分享页面</li>
<li>编写短信分享示例</li>
<li>编写社交分享</li>
</ul>
<p>在这一天，我只完成了前面的三部分。</p>
<h2 id="toolbar-上的分享按钮">Toolbar 上的分享按钮</h2>
<p>在 Toolbar 主要还是靠 ImageView 来绘制右上角的分享按钮：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v7.widget.Toolbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:toolbar=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/toolbar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;?attr/actionBarSize&quot;
    android:background=&quot;?attr/colorPrimaryDark&quot;
    android:gravity=&quot;center&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/toolbar_title&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_gravity=&quot;center&quot;
        android:text=&quot;xxx&quot; /&gt;

    &lt;ImageView
        android:visibility=&quot;invisible&quot;
        android:id=&quot;@+id/share&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingEnd=&quot;@dimen/length_24&quot;
        android:paddingStart=&quot;@dimen/length_16&quot;
        android:paddingTop=&quot;@dimen/length_16&quot;
        android:paddingBottom=&quot;@dimen/length_16&quot;
        android:layout_gravity=&quot;right&quot;
        android:src=&quot;@drawable/share_icon&quot;
        tools:ignore=&quot;RtlHardcoded&quot; /&gt;

&lt;/android.support.v7.widget.Toolbar&gt;</code></pre>
<p>然后在加载到数据的时候，将这个元素变为可见：</p>
<pre><code>share.setVisibility(View.VISIBLE);</code></pre>
<h2 id="短信分享示例">短信分享示例</h2>
<p>在实现 UI 之前，我先写了一个简单的分享功能：</p>
<pre><code>@OnClick(R.id.share)
void shareAction() {
    BaseShare smsShare = ShareFactory.create(&quot;SMS&quot;);
    String text = information.getTitle() + &quot;:&quot; + information.getTitle();
    smsShare.share(this, text);
}</code></pre>
<p>随后将其重构为简单的工厂模式：</p>
<pre><code>public static BaseShare getShareType(String type) {
    switch (type) {
        case &quot;SMS&quot;:
            return new SMSShare();
        case &quot;WEIBO&quot;:
            return new WeiboShare();
        case &quot;MOMENTS&quot;:
            return new MomentsShare();
        case &quot;WECHAT&quot;:
            return new WechatShare();
    }
    return null;
}</code></pre>
<p>对应于不同的分享类型，都有不同的类来做相应的处理。</p>
<h2 id="使用-dialog-绘制底部分享">使用 Dialog 绘制底部分享</h2>
<p>在最开始的时候，我使用的是 Dialog 来绘制底部的布局：</p>
<pre><code>void showShareDialog() {
    Dialog bottomDialog = new Dialog(this, R.style.BottomDialog);
    View contentView = LayoutInflater.from(this).inflate(R.layout.bottom_share, null);
    bottomDialog.setContentView(contentView);

    ViewGroup.LayoutParams layoutParams = contentView.getLayoutParams();
    layoutParams.width = getResources().getDisplayMetrics().widthPixels;
    contentView.setLayoutParams(layoutParams);

    bottomDialog.getWindow().setGravity(Gravity.BOTTOM);
    bottomDialog.setCanceledOnTouchOutside(true);
    
    bottomDialog.getWindow().setWindowAnimations(R.style.BottomDialog_Animation);
    bottomDialog.show();
    }</code></pre>
<p>然后简单地了解了一下动画效果：</p>
<pre><code>&lt;style name=&quot;BottomDialog&quot;&gt;
    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;BottomDialog.Animation&quot; parent=&quot;Animation.AppCompat.Dialog&quot;&gt;
    &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/translate_dialog_in&lt;/item&gt;
    &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/translate_dialog_out&lt;/item&gt;
&lt;/style&gt;</code></pre>
<p>对应的动画文件：</p>
<p>translate_dialog_in:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot;
    android:fromXDelta=&quot;0&quot;
    android:fromYDelta=&quot;100%&quot;
    android:toXDelta=&quot;0&quot;
    android:toYDelta=&quot;0&quot;&gt;
&lt;/translate&gt;</code></pre>
<p>translate_dialog_out:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot;
    android:fromXDelta=&quot;0&quot;
    android:fromYDelta=&quot;0&quot;
    android:toXDelta=&quot;0&quot;
    android:toYDelta=&quot;100%&quot;&gt;
&lt;/translate&gt;</code></pre>
<p>但是绘制的时候，出现了一些问题，即 Dialog 在最上面，随后改用 BottomSheetDialog 来绘制。</p>
<h2 id="使用-bottomsheetdialog-绘制分享菜单">使用 BottomSheetDialog 绘制分享菜单</h2>
<p>对应的逻辑变得更加简单了。</p>
<pre><code>void showShareDialog() {
    final BottomSheetDialog bottomSheetDialog = new BottomSheetDialog(DetailActivity.this);
    View dialogView = LayoutInflater.from(InformationDetailActivity.this).inflate(R.layout.bottom_share, null);

    dialogView.findViewById(R.id.cancel_share).setOnClickListener(view -&gt; {
        bottomSheetDialog.dismiss();
    });

    bottomSheetDialog.setContentView(dialogView);
    bottomSheetDialog.show();
}</code></pre>
<h1 id="大前端-android-开发日记九微博分享">大前端 Android 开发日记九：微博分享</h1>
<p>早期在评估的时候，使用的是第三方 SDK —— shareSDK。可是，这个第三方 SDK 需要注册相应的账号，并且在后台，我们可以看到对应的分享数据。这也就意味着，它会收集一些用户信息，考虑到在这个因素，只好自己编写相应的对接逻辑。</p>
<p>因此，在这一天里，主要做的是微博的分享功能。</p>
<h2 id="短信分享返回">短信分享返回</h2>
<p>在最近设计的时候，在完成短信分享之后，我需要知道它是通知短信分享出去的。就会用到 <code>onActivityResult</code> 来在 Activity 之间数据交流：</p>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);

    if (requestCode == ShareUtil.SMS_REQUEST_CODE) {
        bottomSheetDialog.dismiss();
    }
}</code></pre>
<p>这里的 requestCode 提供给 onActivityResult，是以便确认返回的数据是从哪个 Activity 返回的。这个 requestCode 和 startActivityForResult 中的 requestCode 相对应。即，如下的短信分享逻辑：</p>
<pre><code>context.startActivityForResult(mIntent, ShareUtil.SMS_REQUEST_CODE);</code></pre>
<h2 id="微博分享接入">微博分享接入</h2>
<p>接下来的就是微博分享了，按照官方的文档接入 SDK。配置权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot;/&gt;</code></pre>
<p>对应的 filter</p>
<pre><code>&lt;intent-filter&gt;
    &lt;action android:name=&quot;com.sina.weibo.sdk.action.ACTION_SDK_REQ_ACTIVITY&quot; /&gt;
    &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
&lt;/intent-filter&gt;</code></pre>
<p>在项目的 build.gradle 中添加依赖源</p>
<pre><code>allprojects {
    repositories {
        jcenter()
        google()
        maven { url &quot;https://dl.bintray.com/thelasterstar/maven/&quot; }
    }
}</code></pre>
<p>在应用的 build.gradle 添加对应的依赖</p>
<pre><code>implementation &#39;com.sina.weibo.sdk:core:4.1.5:openDefaultRelease@aar&#39;</code></pre>
<p>然后创建一个实现 WbShareCallback 对象的 Activity：</p>
<pre><code>
@SuppressLint(&quot;Registered&quot;)
public class ShareableActivity implements WbShareCallback {
    private WbShareHandler shareHandler;
    private BottomSheetDialog bottomSheetDialog;
    private IWXAPI api;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        WbSdk.install(this, new AuthInfo(this, ShareUtil.weiboId, &quot;http://www.phodal.com/&quot;, &quot;&quot;));

        shareHandler = new WbShareHandler(this);
        shareHandler.registerApp();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        shareHandler.doResultIntent(intent, this);
    }

    @Override
    public void onWbShareSuccess() {
        bottomSheetDialog.dismiss();
    }

    @Override
    public void onWbShareCancel() {
        bottomSheetDialog.dismiss();
    }

    @Override
    public void onWbShareFail() {
        bottomSheetDialog.dismiss();
    }

    public void showShareDialog(InformationDetailModel information) {
        bottomSheetDialog = new BottomSheetDialog(ShareableActivity.this);
        View dialogView = LayoutInflater.from(ShareableActivity.this).inflate(R.layout.share_dialog, null);

        dialogView.findViewById(R.id.weibo_content).setOnClickListener(view -&gt; {
            weiboShare(information);
        });

        bottomSheetDialog.setContentView(dialogView);
        bottomSheetDialog.show();
    }
    private void weiboShare(InformationDetailModel information) {
        WeiboMultiMessage weiboMessage = new WeiboMultiMessage();
        weiboMessage.mediaObject = ShareUtil.buildWebPageObject(this, information);
        shareHandler.shareMessage(weiboMessage, false);
    }
}</code></pre>
<p>差不多就可以了。</p>
<h1 id="大前端-android-开发日记-10微信分享">大前端 Android 开发日记 10：微信分享</h1>
<p>与之前的微博分享相比，微信分享就没有那么容易了——微信官方的 SDK 太差劲了。文章也写得像一坨屎——因为文档里的代码都是截图的。。。</p>
<h2 id="微信分享-sdk-接入">微信分享 SDK 接入</h2>
<p>按照官方的指南，添加对应的依赖</p>
<pre><code>dependencies {
    compile &#39;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&#39;
}</code></pre>
<p>对应的权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</code></pre>
<p>相关的混淆代码配置：</p>
<pre><code>-keep class com.tencent.mm.opensdk.** { *; }
-keep class com.tencent.wxop.** { *; }
-keep class com.tencent.mm.sdk.** { *; }</code></pre>
<h2 id="注册-wxapi">注册 WXApi</h2>
<p>首先在程序的 Applicaiton 模块中注册、初始化 WXApi，以方便我们在其它模块中使用：</p>
<pre><code>public class InformationApplication extends Application {
    public static IWXAPI wxApi;

    @Override
    public void onCreate() {
        super.onCreate();

        ...

        registerWechat();
    }

    private void registerWechat() {
        wxApi = WXAPIFactory.createWXAPI(this, ShareUtil.weixinAppId, true);
        wxApi.registerApp(ShareUtil.weixinAppId);
    }
    ...
}</code></pre>
<h2 id="分享逻辑">分享逻辑</h2>
<p>IWXAPI 中有一个接口是判断用户是否安装微信，如果没有安装微信，我们应该提醒用户；如果安装了微信，那么才能分享。对应的代码如下所示：</p>
<pre><code>private void wechatShareByType(Model model, int weixinShareType) {
    IWXAPI wxApi = Application.wxApi;

    boolean isWeixinShareable = wxApi.isWXAppInstalled() &amp;&amp; wxApi.isWXAppSupportAPI();
    if (!isWeixinShareable) {
        notInstallWeixinToast();
        return;
    }
    SendMessageToWX.Req req = ShareUtil.buildWXWebPageObject(this, model, weixinShareType);
    wxApi.sendReq(req);
}</code></pre>
<h2 id="使用-wxentryactivity-做出响应">使用 WXEntryActivity 做出响应</h2>
<p>WXEntryActivity 用于分享完后的响应，于是我们需要注册一个新的 WXEntryActivity，并且固定是在 <strong>包名.wxapi</strong> 目录下</p>
<pre><code>&lt;activity
    android:name=&quot;.wxapi.WXEntryActivity&quot;
    android:exported=&quot;true&quot; /&gt;</code></pre>
<p>而这个 Activity 需要实现 IWXAPIEventHandler 的方法</p>
<pre><code>public class WXEntryActivity extends AppCompatActivity implements IWXAPIEventHandler {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Application.wxApi.handleIntent(getIntent(), this);
    }

    @Override
    public void onResp(BaseResp resp) {
    }

    @Override
    public void onReq(BaseReq baseReq) {
    }
}</code></pre>
<h2 id="使用-eventbus-传递事件">使用 EventBus 传递事件</h2>
<p>为了响应上一步的事件，我使用了 EventBus 来做对应的处理。只需要在 WXEntryActivity 中的 Response 里 post 事件即可：</p>
<pre><code>@Override
public void onResp(BaseResp resp) {
    WeixinEvent weiXin = new WeixinEvent(2, resp.errCode, &quot;&quot;);
    EventBus.getDefault().post(weiXin);
    finish();
}</code></pre>
<p>对应的在订阅者里，我需要先注册事件：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ...
    EventBus.getDefault().register(this);
}

@Override
protected void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
}</code></pre>
<p>然后才能使用：</p>
<pre><code>@Subscribe
public void onEventMainThread(WeixinEvent weixinEvent) {

}</code></pre>
<p>这样，我就可以才分享的 Activity 里获取分享的状态了。</p>
<h1 id="大前端-android-开发日记-11日历创建">大前端 Android 开发日记 11：日历创建</h1>
<p>在写了一些业务代码之后，终于有机会去处理一些坑了——日历。业务上的需求是，用户可以添加对应的日历提醒，因此就开始这一天的挖坑之旅了。</p>
<h2 id="日历权限">日历权限</h2>
<p>首先，在 AndroidManifest.xml 中加入 <code>READ_CALENDAR</code> 权限。为了删除、插入或者更新日历数据，则需要添加 <code>WRITE_CALENDAR</code> 权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_CALENDAR&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_CALENDAR&quot; /&gt;</code></pre>
<h2 id="权限判断">权限判断</h2>
<p>然后添加一些权限判断代码：</p>
<pre><code>private static boolean hasReadCalendarPermissions(Activity activity) {
    return PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(activity, Manifest.permission.READ_CALENDAR);
}</code></pre>
<h2 id="请求权限">请求权限</h2>
<p>对于高版本的 Android 系统来说，还需要动态地请求权限：</p>
<pre><code>public static void requestCalendarPermissions(Activity activity) {
    if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; !CalenderHelper.hasReadCalendarPermissions(activity)) {
        int request = ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_CALENDAR);
        if (request != PackageManager.PERMISSION_GRANTED) {
            PERMISSION_REQUEST_CODE++;
            ActivityCompat.requestPermissions(activity, new String[]{
                    Manifest.permission.WRITE_CALENDAR,
                    Manifest.permission.READ_CALENDAR
            }, PERMISSION_REQUEST_CODE);
        }

    }
}</code></pre>
<h2 id="请求权限回调">请求权限回调</h2>
<p>请求完权限后，可以通过 <code>onRequestPermissionsResult</code> 来知道，是否能添加日历。</p>
<pre><code>@SuppressLint(&quot;ShowToast&quot;)
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);

    if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_DENIED) {
        Toast.makeText(this.getContext(), &quot;请求日历权限失败&quot;, Toast.LENGTH_LONG);
    } else if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {
        Toast.makeText(this.getContext(), &quot;请求日历权限成功，请重新添加!&quot;, Toast.LENGTH_LONG);
    }
}</code></pre>
<h2 id="添加前检测权限">添加前检测权限</h2>
<p>如果用户如果权限，并且想添加日历事件的时候，我们仍然需要做一个检测：</p>
<pre><code>public static void addEvent(Context context, CalendarModel calendar) {
    if (!CalenderHelper.hasReadCalendarPermissions((Activity) context)) {
        CalenderHelper.requestCalendarPermissions((Activity) context);
    }

    if (CalenderHelper.hasReadCalendarPermissions((Activity) context)) {
        addEventByCalendar(context, calendar);
    }
}</code></pre>
<h2 id="创建日历事件">创建日历事件</h2>
<p>在结束了权限相关的话题之后，我们就可以创建一个日历事件了。按照 Google Android 官方的文档，就可以拼出我们的事件：</p>
<pre><code>ContentValues event = new ContentValues();
Calendar mCalendar = Calendar.getInstance();
mCalendar.setTime(beginTime);
long start = mCalendar.getTime().getTime();
long end = mCalendar.getTime().getTime();

event.put(CalendarContract.Events.CALENDAR_ID, 1);
event.put(CalendarContract.Events.TITLE, calendar.getTitle());
event.put(CalendarContract.Events.DESCRIPTION, &quot;Description&quot;);
event.put(CalendarContract.Events.DTSTART, start);
event.put(CalendarContract.Events.DTEND, end);
event.put(CalendarContract.Events.HAS_ALARM, 1);
event.put(CalendarContract.Events.EVENT_TIMEZONE, &quot;Asia/Shanghai&quot;);

Uri newEvent = context.getContentResolver().insert(Uri.parse(CALENDER_EVENT_URL), event);
if (newEvent == null) {
    return;
}</code></pre>
<h2 id="添加提醒">添加提醒</h2>
<p>添加完日历之后，我们可以顺便添加一个提醒：</p>
<pre><code>ContentValues values = new ContentValues();
values.put(CalendarContract.Reminders.EVENT_ID, ContentUris.parseId(newEvent));

values.put(CalendarContract.Reminders.MINUTES, 5);
values.put(CalendarContract.Reminders.METHOD, CalendarContract.Reminders.METHOD_ALERT);
Uri uri = context.getContentResolver().insert(Uri.parse(CALENDER_REMINDER_URL), values);
if (uri == null) {
    return;
}</code></pre>
<h2 id="获取所有的日历">获取所有的日历</h2>
<p>添加完日历之后，就可以获取日历来测试了。按照官方的示例，写了以下的代码：</p>
<pre><code>ContentUris.appendId(uriBuilder, eStartDate.getTimeInMillis());
ContentUris.appendId(uriBuilder, eEndDate.getTimeInMillis());

Uri uri = uriBuilder.build();

String selection = &quot;((&quot; + CalendarContract.Instances.BEGIN + &quot; &gt;= &quot; + eStartDate.getTimeInMillis() + &quot;) &quot; +
        &quot;AND (&quot; + CalendarContract.Instances.END + &quot; &lt;= &quot; + eEndDate.getTimeInMillis() + &quot;) &quot; +
        &quot;AND (&quot; + CalendarContract.Instances.VISIBLE + &quot; = 1) )&quot;;

cursor = cr.query(uri, new String[]{
        CalendarContract.Instances.EVENT_ID,
        CalendarContract.Instances.TITLE,
        CalendarContract.Instances.DESCRIPTION,
        CalendarContract.Instances.BEGIN,
        CalendarContract.Instances.END
}, selection, null, null);
ArrayList&lt;String&gt; nameOfEvent = new ArrayList&lt;&gt;();

if (cursor != null &amp;&amp; cursor.moveToFirst()) {
    String CNames[] = new String[cursor.getCount()];
    for (int i = 0; i &lt; CNames.length; i++) {
        nameOfEvent.add(cursor.getString(1));
        CNames[i] = cursor.getString(1);
        cursor.moveToNext();
    }
    cursor.close();
}

return nameOfEvent;</code></pre>
<p>手动拼写 QUERY，想死的感觉都有了。尝试了很多之后，终于写出可以工作的代码了。</p>
<h1 id="大前端-android-开发日记-12删除日历状态变化">大前端 Android 开发日记 12：删除日历、状态变化</h1>
<p>有了上一天的基础，就可以一步步地实现业务代码了。</p>
<h2 id="合并日历的状态">合并日历的状态</h2>
<p>由于不熟悉 rxJava，不知道怎么用 Java 来合并类似于 JavaScript 中的多个 Promise 的东西。找了项目上的 Android 大牛，写了如下的代码：</p>
<pre><code>Flowable.fromCallable(() -&gt; CalenderHelper.findEventCalendars(context, date))
        .zipWith(getCalendar(date), (localEvents, remoteCalendars) -&gt; {
            List&lt;CalendarModel&gt; calendarList = remoteCalendars.getData();

            ...

            return calendarList;
        })
        .compose(RxjavaUtils.flowableIoTransformer())
        .subscribe(callback::onLoadCalendarComplete, callback::onLoadCalendarFailed);</code></pre>
<p>首先从本地获取指定日志的所有日历，然后再通过 <code>getCalendar</code> 方法从远程获取日历，随后在 <code>zipWith</code> 方法中，来 merge 两个日历。</p>
<h2 id="删除日历">删除日历</h2>
<p>删除日历倒是比之前的内容简单一些，我们只需要找到对应的日历事件的 ID，然后就可以删除了。</p>
<pre><code>public static void removeEvent(Context context, int indexId, int eventID) {
    Uri deleteUri;
    deleteUri = ContentUris.withAppendedId(Uri.parse(calenderEventUrl), eventID);
    int rows = context.getContentResolver().delete(deleteUri, null, null);
    Timber.d(&quot;Rows deleted: &quot; + rows);

    RemoveCalenderEvent removeCalenderEvent = new RemoveCalenderEvent(indexId, eventID);
    EventBus.getDefault().post(removeCalenderEvent);
}</code></pre>
<p>在这个过程中，最初我犯了一个错误，那就是最开始我找的是日历的 CALENDAR_ID，而不是 EVENT_ID。</p>
<h2 id="实时更新日历状态">实时更新日历状态</h2>
<p>创建日历的时候，发出一个对应的事件：</p>
<pre><code>CreateCalenderEvent createCalenderEvent = new CreateCalenderEvent(calendar.getId(), (int) eventId);
EventBus.getDefault().post(createCalenderEvent);</code></pre>
<p>随后在 Activity 里，来接收相应的事件：</p>
<pre><code>@SuppressLint(&quot;ShowToast&quot;)
@Subscribe
public void onRemoveCalendarThread(RemoveCalenderEvent removeCalenderEvent) {
    Toast.makeText(this.getContext(), &quot;取消提醒成功 &quot;, Toast.LENGTH_LONG);
    int id = removeCalenderEvent.getId();
    int eventID = removeCalenderEvent.getEventId();
    Timber.d(&quot;取消提醒成功 &quot; + id);

    calendarAdapter.updateItem(id, eventID, &quot;remove&quot;);
}</code></pre>
<p>接着在我们的 Adapter 里更新对应的日历，然后使用 <code>notifyItemChanged</code> 来刷新整个 item 的视图。</p>
<pre><code>public void updateItem(int updateItemId, int eventID, String updateType) {
    CalendarModel item = null;

    ...

    if (updateType.equals(&quot;create&quot;)) {
        item.setEventId(eventID);
    } else if (updateType.equals(&quot;remove&quot;)) {
        item.setEventId(0);
    }

    calendarList.set(index, item);
    notifyItemChanged(index);
}</code></pre>
<h1 id="大前端-android-开发日记-13动态更新日历状态">大前端 Android 开发日记 13：动态更新日历状态</h1>
<p>继续之前的日志开发，在之前的文章中，我们已经可以从系统日历里读取、删除、添加日历了。</p>
<p>在这一篇里，我要总结提：每当我添加或者删除日历的时候，我需要同时更新页面上的元素。因此，在这里我们分为了四个步骤：</p>
<ol type="1">
<li>使用 EventBus 创建通知事件</li>
<li>接收事件，并传递给 Adapter</li>
<li>更新 Item</li>
<li>更新状态</li>
</ol>
<h2 id="动态更新日历状态">动态更新日历状态</h2>
<h3 id="使用-eventbus-创建通知事件">1.使用 EventBus 创建通知事件</h3>
<p>由于之前已经介绍过 EventBus 的相关内容，这里简单地列一下代码就好了：</p>
<pre><code>CreateCalenderSuccessEvent createCalenderSuccessEvent = new CreateCalenderSuccessEvent(calendar.getId(), (int) eventId);
        EventBus.getDefault().post(createCalenderSuccessEvent);</code></pre>
<h3 id="接收事件并传递给-adapter">2.接收事件，并传递给 Adapter</h3>
<p>随后在我们的 Activity 中接收相应的事件，然后调用 Adapter 中的方法：</p>
<pre><code>@SuppressLint(&quot;ShowToast&quot;)
@Subscribe
public void onCreateCalendarThread(CreateCalenderSuccessEvent createCalenderSuccessEvent) {
    ...

    calendarAdapter.updateItem(id,  eventID, &quot;create&quot;);
}</code></pre>
<h3 id="更新-item">3. 更新 Item</h3>
<p>然后根据传过来的更新类型，我们来为对应的 item 修改 eventid 的值：</p>
<pre><code>public void updateItem(int updateItemId, int eventID, String updateType) {
    CalendarModel item = null;
    ...

    if (updateType.equals(&quot;create&quot;)) {
        item.setEventId(eventID);
    } else if (updateType.equals(&quot;remove&quot;)) {
        item.setEventId(0);
    }

    calendarList.set(index, item);
    notifyItemChanged(index);
}</code></pre>
<h3 id="更新状态">4. 更新状态</h3>
<p>最近根据有没有 eventid，来决定是否显示的内容：</p>
<pre><code>if (calendar.getEventId() != 0) {
    calendar_reminder_.setText(R.string.cancel);
} else {
    text.setText(R.string.title);
}</code></pre>
<h1 id="大前端-android-开发日记-14纯-html-的-webview-loading-效果">大前端 Android 开发日记 14：纯 HTML 的 WebView Loading 效果</h1>
<p>因为 HTTP 请求 + WebView 的渲染时间问题，我们决定为 WebView 添加一个 Loading 效果。于是，在这一天里，做的主要也就是这一方面的工作。</p>
<p>不过，一开始的时候，没有意识到我们的 WebView 和一般的 WebView 是不一样的，也就掉坑里了。我们的 WebView 是使用纯 HTML 渲染的文章内容，也就是后台只返回一个纯的 HTML 文本，不需要去远程请求。</p>
<h2 id="通常的-webview-loading-效果">通常的 WebView Loading 效果</h2>
<p>一般来说，通过以下的代码就可以为 WebView 添加一个 Loading 显示和隐藏的效果：</p>
<pre><code>public class AppWebViewClients extends WebViewClient {
    private ProgressBar progressBar;

    public AppWebViewClients(ProgressBar progressBar) {
        this.progressBar = progressBar;
    }

    @Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
        // TODO Auto-generated method stub
        view.loadUrl(url);
        return true;
    }

    @Override
    public void onPageStarted(WebView view, String url, Bitmap favicon) {
        super.onPageStarted(view, url, favicon);
    }

    @Override
    public void onPageFinished(WebView view, String url) {
        // TODO Auto-generated method stub
        super.onPageFinished(view, url);
        progressBar.setVisibility(View.GONE);
    }
}</code></pre>
<p>也就是在 <code>onPageFinished</code> 的时候，隐藏 progressBar。后来，我发现我们的 progressBar 不会显示，因为这里的 <code>onPageFinished</code> 是 WebView 完成 HTTP 请求触发的事件。</p>
<h2 id="本地-webview-loading-效果">本地 WebView Loading 效果</h2>
<p>于是，我改用覆写 WebView 的方式，通过 onProgressChanged 来实时监测变化，最后等到 100% 再隐藏 hide</p>
<pre><code>public class ProgressWebView extends WebView {

    private AVLoadingIndicatorView spinner;

    public ProgressWebView(Context context, AttributeSet attrs) {
        super(context, attrs);

        setWebChromeClient(new WebChromeClient());
    }

    public void setSpinner(AVLoadingIndicatorView spinner) {
        this.spinner = spinner;
    }

    public class WebChromeClient extends android.webkit.WebChromeClient {
        @Override
        public void onProgressChanged(WebView view, int newProgress) {
            if (newProgress == 100) {
                spinner.hide();
            }
            super.onProgressChanged(view, newProgress);
        }
    }
}
``

对应的布局：

</code></pre>
<p>&lt;com.wang.avi.AVLoadingIndicatorView android:id=“@+id/spinner” app:indicatorColor=“<span class="citation" data-cites="color/cmb_gold">@color/cmb_gold</span>” … /&gt;</p>
<p>&lt;com.cmb.plugin.information.view.ProgressWebView android:id=“@+id/webview” … /&gt;</p>
<pre><code>
尽管没有完全实现在 WebView 渲染完成时，再隐藏的方式，但是勉强可以完成需求。要在 WebView 渲染完时，再隐藏，最简单的方式就是流入 JavaScript，让其在 ``window.onload`` 时告诉原生代码，渲染已完成。


大前端 Android 开发日记 14：Android WebView 默认 margin 样式问题
===

这一也没啥做的，不过也算是修了一个 CSS 的样式问题。

这个问题的主要来源是，后端返回的 HTML 是不带样式的，而默认的 WebView 会为 Div 标签加上 8px 的 padding，也就是说没有 CSS Reset。这个时候，就需要手动加一个 Reset 效果了，于是就写了一个简单的方法来做这件事。顺便带页面的内容，包在了 body 中。
</code></pre>
public class WebViewUtil { public static String removeDefaultStyle(String originContent) { return “
<body style="margin:0;padding:0;background-color: transparent;">
&quot; + originContent + “
</body>
<p>“; } }</p>
<pre><code>
Reset 的 CSS 的内容就是：
</code></pre>
<p>margin:0; padding:0; ```</p>
<p>然后在一次新的测试中，发现了样式中又默认了白色背景，于是就加了一个背景透明 <code>background-color: transparent;</code>。</p>
</body>
</html>
